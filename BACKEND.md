# Raise The Bar Backend Logic (Current + Two‑Player Blueprint)

**Purpose**
This document explains how the app’s backend logic works today and lays out a clean path to extend the same flow for a two‑player mode.

**High‑Level Architecture**
The app has no custom server. All “backend” behavior is handled from the browser via third‑party APIs:

```
Browser UI (React)
  ├─ ElevenLabs Realtime Scribe (speech → text)
  ├─ Featherless + K2 (LLM judge panel)
  └─ Supabase (storage: transcripts, grades, feedback)
```

**Core Services**
1. ElevenLabs Realtime Scribe  
   - Used for live transcription.  
   - A short‑lived token is fetched at recording start and passed to `useScribe`.  
   - Partial and committed transcripts stream back into the UI state.

2. Featherless AI + K2  
   - Four judges are invoked in parallel (`DeepSeek‑V3`, `Llama‑3.3‑70B`, `Qwen‑2.5‑72B`, `K2‑Think‑v2`).  
   - Each judge returns structured JSON for category scores, an overall score, and feedback.  
   - Results are parsed, normalized, and averaged to produce a final grade and breakdown.

3. Supabase  
   - Stores transcripts and the generated grade/feedback.  
   - Used as the source of truth for saved results displayed in the UI.

**Environment Configuration**
The app reads these env vars at runtime:

- `VITE_ELEVEN_LABS_API_KEY`
- `VITE_FEATHERLESS_API_KEY`
- `VITE_K2_API_KEY`
- `VITE_SUPABASE_URL`
- `VITE_SUPABASE_ANON_KEY`

**Current Data Model (Supabase)**
The code expects a `transcripts` table with fields that look like:

- `id` (primary key, generated by Supabase)
- `text` (string)
- `created_at` (timestamp, ISO string)
- `grade` (string, e.g. `A- (8.2/10)`)
- `feedback` (string, concatenated judge blurbs)

If you add columns, they won’t affect the current flow unless you read them in the UI.

**Runtime Flow (Today)**
1. User starts recording  
   - The app requests a short‑lived ElevenLabs token.  
   - `useScribe.connect` begins streaming speech recognition.  
   - Partial transcript text is updated live as the user speaks.

2. User stops recording  
   - The final transcript is built by merging committed text + any remaining partial text.  
   - If the text length is over a minimal threshold, the app proceeds.

3. Persist transcript  
   - `saveTranscript(text)` inserts into Supabase with `created_at`.  
   - The returned row is held in memory to update with grades later.

4. Judge panel grading  
   - `getJudgePanel(text)` fans out to four models in parallel.  
   - Each response is parsed into a normalized score set.  
   - If parsing fails, smart defaults are generated from transcript analysis.

5. Store grade + feedback  
   - The app builds a grade string and feedback summary.  
   - `updateTranscriptGrade(id, grade, feedback)` writes this back to Supabase.  
   - The UI shows the results and prepends the new record to “Battle History.”

**Judge Panel Logic**
The judge engine (`src/featherless.js`) handles:

- Prompting per judge personality.
- Parsing JSON safely (tolerating extra text).
- Generating fallback verdicts if parsing fails.
- Lightweight transcript analysis for generic tips when needed.
- Aggregating all judge scores into average categories.
- Producing grade letters and human‑readable verdict messages.

This keeps the UI responsive even when individual models fail.

**Error Handling**
- If saving to Supabase fails, the UI shows an error and stops the grading path.  
- If grading fails, the transcript is still saved; the UI falls back to showing a saved record without full grading.  
- Missing API keys trigger early errors and prevent external calls.

**What’s Not a Backend**
There is no custom API server in this repo. All calls are made directly from the browser to third‑party services. For production hardening, you’d typically proxy those calls through a server to keep keys private.

---

## Two‑Player Mode Blueprint
Below is a drop‑in design that mirrors the current logic but supports head‑to‑head battles.

**Goals**
- Keep the same judge panel and grading logic.  
- Track two performers in the same match.  
- Store results in a way that supports history and replay.  
- Allow both players to see synchronized state.

**Data Model Extension**
Option A: Extend `transcripts` table.

- Add `match_id` (string/uuid)
- Add `player_id` (string, e.g. `p1`, `p2`, or user id)
- Add `round_index` (integer)
- Add `sequence_index` (integer, ordering within the round)

Option B: Add normalized tables.

- `matches`  
  - `id`, `status`, `created_at`, `finished_at`, `winner_player_id`
- `players`  
  - `id`, `display_name`, `created_at`
- `rounds`  
  - `id`, `match_id`, `round_index`
- `performances`  
  - `id`, `match_id`, `player_id`, `round_index`, `text`, `grade`, `feedback`, `created_at`

**Session Flow (Two Players)**
1. Create match  
   - Insert `matches` row and return a share code or match id.

2. Join match  
   - Player 1 and Player 2 connect to the same match id.  
   - Both clients subscribe to Supabase Realtime on `matches` and `performances`.

3. Recording sequence  
   - Each player records in their assigned phase.  
   - The exact order can be fixed or alternate by round.

4. Grading + save  
   - For each performance, call `getJudgePanel` exactly as today.  
   - Save results tied to `match_id` and `player_id`.

5. Determine round winner  
   - Compare `avgScore` per player for the round.  
   - Update match state with running totals.

6. End match  
   - Persist winner and close the match.  
   - Render a final scoreboard and battle history.

**State Changes in the UI**
Minimal refactor if you keep existing logic:

- Replace `transcript` with `transcriptsByPlayer`  
  - Example: `{ p1: { text, partial }, p2: { text, partial } }`
- Replace `judgeResults` with `judgeResultsByPlayer`
- Replace `savedTranscripts` with `performancesByMatch`

All existing judge and Supabase logic can be reused per player.

**Realtime Sync (Recommended)**
Use Supabase Realtime for:

- Match status (`waiting`, `recording_p1`, `recording_p2`, `grading`, `complete`)  
- Live updates to performance rows  
- Synchronized UI state between players

**Security Note**
For two‑player sessions, external API keys become more exposed.  
A lightweight serverless proxy for ElevenLabs and judge calls is recommended if you plan to ship.

---

## File Map (Current)
- `src/App.jsx`: main orchestration of recording, saving, and judging  
- `src/supabase.js`: Supabase client + CRUD helpers  
- `src/featherless.js`: judge panel orchestration + scoring logic  
- `src/k2.js`: alternate K2 grader (not wired into the main UI)  

If you want, I can follow up by implementing the two‑player data model and wiring it into the current React flow.
